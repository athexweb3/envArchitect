use serde::{Deserialize, Serialize};
use wasmparser::{Parser, Payload};

#[derive(Debug, Serialize, Deserialize)]
pub struct ScanReport {
    pub status: ScanStatus,
    pub score: u8, // 0-100 (100 = Safe)
    pub detected_imports: Vec<String>,
    pub suspicious_strings: Vec<String>,
    pub instructions: InstructionStats,
}

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ScanStatus {
    Safe,
    Suspicious,
    Malicious,
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct InstructionStats {
    pub loops: usize,
    pub math_ops: usize,
    pub total: usize,
}

pub fn scan_artifact(wasm_bytes: &[u8]) -> anyhow::Result<ScanReport> {
    let mut detected_imports = Vec::new();
    let mut suspicious_strings = Vec::new();
    let mut stats = InstructionStats::default();

    let parser = Parser::new(0);
    for payload in parser.parse_all(wasm_bytes) {
        match payload? {
            Payload::ImportSection(reader) => {
                for import in reader {
                    let import = import?;
                    let full_name = format!("{}.{}", import.module, import.name);

                    // Suspicious Import Heuristic
                    if full_name.starts_with("env.exec")
                        || full_name.starts_with("env.eval")
                        || full_name.starts_with("env.system")
                    {
                        detected_imports.push(full_name);
                    }
                }
            }
            Payload::DataSection(reader) => {
                for data in reader {
                    let data = data?;
                    if let Ok(s) = std::str::from_utf8(data.data) {
                        // Regex for C2 (IPs, basic URL)
                        // Simple check for now to avoid false positives on local IPs
                        if s.contains("xmrig") || s.contains("monero") {
                            suspicious_strings.push(s.to_string());
                        }
                    }
                }
            }
            Payload::CodeSectionEntry(body) => {
                let mut reader = body.get_operators_reader()?;
                while !reader.eof() {
                    let op = reader.read()?;
                    stats.total += 1;

                    match op {
                        wasmparser::Operator::Loop { .. } => stats.loops += 1,
                        wasmparser::Operator::F64Mul
                        | wasmparser::Operator::F32Mul
                        | wasmparser::Operator::I64Add
                        | wasmparser::Operator::I64Mul => {
                            stats.math_ops += 1;
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
    }

    // Scoring Logic
    let mut score = 100;
    let mut status = ScanStatus::Safe;

    // 1. Critical Imports -> Instant Malicious/Suspicious
    if !detected_imports.is_empty() {
        score = 0;
        status = ScanStatus::Suspicious; // Might be a valid plugin doing system stuff, but flag it.
    }

    // 2. Miner Heuristic
    if stats.total > 100 {
        let math_ratio = stats.math_ops as f64 / stats.total as f64;
        if math_ratio > 0.5 && stats.loops > 5 {
            score = 10;
            status = ScanStatus::Malicious;
            suspicious_strings
                .push("High density arithmetic loop detected (Possible Miner)".into());
        }
    }

    // 3. String Matches
    if !suspicious_strings.is_empty() && status == ScanStatus::Safe {
        score -= 20 * suspicious_strings.len() as u8;
        if score < 50 {
            status = ScanStatus::Suspicious;
        }
    }

    Ok(ScanReport {
        status,
        score,
        detected_imports,
        suspicious_strings,
        instructions: stats,
    })
}
